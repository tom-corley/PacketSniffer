// === Include Statements
#include "analysis.h"

#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <stdbool.h>

#include <pthread.h>
#include <pcap.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

// === Global Variables ===


// Global counts for packet analysis, unchanged until after all packet processing complete.
long long syn_count = 0;
long long ip_count = 0;
long long arp_resp_count = 0;
long long blk_url_count = 0;
long long ggl_count = 0;
long long analysed = 0;

// Mutex locks to make access to IP Tree and printing to terminal thread safe.
pthread_mutex_t ip_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t print_mutex = PTHREAD_MUTEX_INITIALIZER;

// Declarations for Blacklisted URL violation
const char* BLACKLISTED_DOMS[] = {"www.google.co.uk", "www.bbc.co.uk"};
const int BLACKLISTED_NUM = 2;

// === Functions ===

/**
 * Analysis function to be called on individual packets. 
 * Detects and counts SYN packets, ARP Requests, and HTTP requests to blacklisted domains
 * Arguments : 
 *  header: pointer to pcap_pktheader struct for packet generated by pcap library
 *  packet: char pointer (string) to raw contents of packet
 *  verbose: flag to indicate whether details should be printed to terminal
 *  stats: pointer to ThreadStats object to update worker thread counts
*/
void analyse(const struct pcap_pkthdr *header,
             const unsigned char *packet_data,
             int verbose, ThreadStats *stats) {      
  // Cast raw packet data to extract ethernet header at link layer.
  struct ether_header* eth_header = (struct ether_header* ) packet_data;

  // * Read the protocol of the next layer (network), to check for IP and ARP packets *

  // Case 1: ethernet type is ARP, check if packet is response, if so count it (Cache Poisoning).
  if (ntohs(eth_header->ether_type) == ETHERTYPE_ARP) {
    // Cast rest of packet (skipping ethernet (link layer) header) to an arp struct, and extract the arp header.
    struct ether_arp* arp_packet_raw = (struct ether_arp *)(packet_data + 14); // 14 is fixed length of ethernet header.
    struct arphdr *arp_header = (struct arphdr *)&arp_packet_raw->ea_hdr;

    // Check if ARP packet is a reply, and if so increment worker thread's counter.
    if (ntohs(arp_header->ar_op) == ARPOP_REPLY) {
      stats->arp_ct++;
    }

  // Case 2: ethernet type is IP
  } else if (ntohs(eth_header->ether_type) == ETHERTYPE_IP) {
    // Extract the network layer IP header, and determine length (in bytes).
    struct ip *ip_header = (struct ip *)(packet_data + 14);
      int ip_length = ip_header->ip_hl * 4; // Words to bytes conversion.
      char* temp = inet_ntoa(ip_header->ip_src);

    // Check if packet uses TCP at transport layer.
    if (ip_header->ip_p == 6) {

      // Extract transport layer header (skip sum of of link and network layer lengths) and determine length.
      struct tcphdr *tcp_header = (struct tcphdr *)(packet_data + 14 + ip_length);
      int tcp_length = 4 * tcp_header->doff; // Words to bytes conversion.

      // First we check for a SYN packet by checking if only the control flag SYN is set.
      if (tcp_header->th_flags == TH_SYN) {
        // Increment worker thread's counter.
        stats->syn_ct++;

        // Save source IP address dynamically on heap.
        char* src_ip = (char *)safe_mlc(strlen(temp) + 1);
        strcpy(src_ip, temp);

        // Critical Section: Add it to tree of unique IPs (only adds if not already in tree).
        pthread_mutex_lock(&ip_mutex);
        int added = 0;
        ip_tree->root = add_ip(src_ip, ip_tree->root, &added);
        ip_count += added;
        pthread_mutex_unlock(&ip_mutex);
      }


      // Second check for HTTP (Port 80) packets.
      if (ntohs(tcp_header->dest) == 80) {

        // We then determine the length of the application layer (HTTP) header.
        int http_length = ntohs(ip_header->ip_len) - ip_length - tcp_length; // Subtract Layer 2 and 3 lengths from 2,3,4 length.

        // We then need to process the http data, first we copy it over into a char pointer, which we allocate memory for.
        char* http_data = safe_mlc(sizeof(char) * http_length + 1); // We need extra space for null character.
        memcpy(http_data, (packet_data + 14 + ip_length + tcp_length), http_length);
        http_data[http_length] = '\0'; // So string functions work
        for (int i = 0; i < BLACKLISTED_NUM; i++) {
          // Search for each blacklisted url as substring in data.
          if (strstr(http_data, BLACKLISTED_DOMS[i])) {
              // Increment worker thread's count.
              stats->url_ct++;
              // Increment google counter if google, can just subtract this from blk_url_count to get bbc
              if (i == 0) {
                stats->ggl_ct++;
              }
              // Critical Section: Output details to terminal.
              pthread_mutex_lock(&print_mutex);
              printf("=============\nBlacklisted URL violation detected, attempted access to %s.\n", BLACKLISTED_DOMS[i]);
              printf("Source IP Address: %s\n", inet_ntoa(ip_header->ip_src));
              printf("Destination IP Address: %s (", inet_ntoa(ip_header->ip_dst));
              if (i == 0) {printf("google");} else {printf("bbc");}
              printf(")\n=============\n");
              pthread_mutex_unlock(&print_mutex);
          }
        }
        // Free allocated memory.
        free(http_data);
      }
    }
  }
  // Increment counter of packets which have been analysed by the running worker thread.
  stats->ays_ct++;
}

/*
 * Creates a ip node with inputted ip on the heap, and returns pointer to it 
 * Arguments:
  ip: character pointer to the ip address saved on the heap
 * Returns: pointer to the freshly created IP node
*/
IpNode *create_ip_node(char *ip) {
  // Safely allocate memory for node and initialise fields.
  IpNode *node = (IpNode *)safe_mlc(sizeof(IpNode));
  node->ip = ip; node->left = NULL; node->right = NULL;

  // Return pointer to node.
  return node;
}

/* 
 * Function to add an ip address to the ip tree, if it is not already in the tree.
 * Conducts a binary search in a tree, for a given ip address, if it finds it, returns unchanged tree.
 * Otherwise, adds a node in the correct place, and returns the modified tree.
 * Arguments:
 *  ip: ip address as a character pointer saved on the heap
 *  node: root of tree (or subtree in recursive calls) to which ip should be (or shouldn't be) added
 *  added: integer pointer, used to keep track of size of tree by recording when an ip was added
 * Returns: modified (or unmodified) tree/subtree
*/
IpNode *add_ip(char *ip, IpNode *node, int *added) {
  // Executes recursively.

  // If the node is empty, add a node at that address.
  if (node == NULL) {
    node = create_ip_node(ip);
    *added = 1; // Record that a new node was added to the tree.
    return node; 
  }

  // If we are not yet at an empty node, search recursively through tree, using string comparison.
  int diff = strcmp(ip, node->ip);
  if (diff > 0) { // Add to right subtree.
    node->right = add_ip(ip, node->right, added);
  } else if (diff < 0) { // Add to left subtree.
    node->left = add_ip(ip, node->left, added);
  } else { // Found in tree, do not add.
    // Free IP from heap as we do not need it.
    free(ip); 
  }
  return node; // Return (un)modified tree.
}

/*
 * Prints an inorder traversal of the tree, done recursively, for debugging.
 * Arguments:
 *  node: root of tree/subtree to traverse in-order
*/
void inorder(struct IpNode *node)
{
    // Standard recursive in-order traversal, prints out each node.
    if (node != NULL) {
        inorder(node->left);
        printf("IP: %s \n", node->ip);
        inorder(node->right);
    }
}

/*
 * Deallocates all memory on the heap used by a tree, done recursively.
 * Postfix traversal is used to ensure pointers to child nodes are not lost.
 * Arguments: 
 *  node: Root of tree/subtree to deallocate 
*/
void postorder_deallocate(IpNode *node) {
  if (node == NULL) {
    // If node has null address, there is nothing to free, return.
    return;
  } else {
    // Otherwise, free left and right subtrees, then node itself.
    postorder_deallocate(node->left);
    postorder_deallocate(node->right);
    free(node->ip);
    free(node);
  }
}