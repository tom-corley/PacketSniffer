// === Include Statements ===

#include "dispatch.h"
#include "analysis.h"
#include "sniff.h"

#include <stdlib.h>
#include <pcap.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>
#include <stdbool.h>

// === Global variables ===

long long packet_count;
const int THREADPOOL_SIZE = 10;
pthread_t *worker_thread_ids;

// Mutex and condition variables for packet queue.
pthread_mutex_t pkt_q_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t pkt_q_cond = PTHREAD_COND_INITIALIZER;

pthread_mutex_t counts_mutex = PTHREAD_MUTEX_INITIALIZER;

// Flags to indicate to threads.
int should_terminate = 0;

// Queue of packets to be processed by some thread. 
PacketQueue *pkt_q = NULL;

// Binary Tree to store unique IP addresses.
IpTree *ip_tree = NULL;

// === Functions ===

/* 
 * Called to add individual packet to thread pool.
 * Arguments: 
 * 	user: Additional arguments for pcap_handler. Unused in this case. 
 *  header: Packet header generated by pcap library. 
 * 	bytes: Raw packet bytes.  
 */
void dispatch(unsigned char *user,
              const struct pcap_pkthdr *header,
              const unsigned char *packet_data) {

  // Print packet details to terminal, if verbose.
  if (verbose == 1) {
    dump(packet_data, header->len);
  }

  // Allocate and initialise new packet object to add to thread pool.
  Packet *p = safe_mlc(sizeof(Packet));
  p->next = NULL;

  // Copy data and save to packet struct.
  unsigned char *packet_data_copy = safe_mlc((sizeof(char)) * header->len);
  memcpy(packet_data_copy, packet_data, header->len);
  p->packet_data = packet_data_copy;

  // Copy header and save to packet struct.
  struct pcap_pkthdr *header_copy = safe_mlc(sizeof(struct pcap_pkthdr));
  memcpy(header_copy, header, sizeof(struct pcap_pkthdr));
  p->header = header_copy;

  // Critical Section: Enqueue the packet and broadcast this action to the worker threads.
  pthread_mutex_lock(&pkt_q_mutex);
  enqueue_packet(p);
  pthread_cond_broadcast(&pkt_q_cond);
  pthread_mutex_unlock(&pkt_q_mutex);
  
  // Increment global packet counter.
  packet_count++;
}

/** 
 * Worker Thread Entry Function.
 * Arguments:
 *    arg: Standard argument for pthreads library, unused
 */
void* worker_thread_function(void *arg) {
    // Dynamically allocate and initialise structure to track counts.
    ThreadStats *stats = (ThreadStats *)safe_mlc(sizeof(ThreadStats));
    stats->syn_ct = 0; stats->arp_ct = 0; stats->url_ct = 0;  stats->ggl_ct=0; stats->ays_ct = 0;

    // Packet Processing (this for loop) continues until both of the following two conditions are met:
    // a) the queue is empty    AND    b) the Ctrl C signal to end runtime has been sent.
    for (;;) {
        // Acquire mutex lock on packet queue
        pthread_mutex_lock(&pkt_q_mutex);

        // To save CPU resources, If the queue is empty, but program shouldn't terminate, thread is put to sleep.
        while (is_pkt_q_empty() && (should_terminate == 0)) {
            // Release mutex, wait idly, and then reacquire mutex lock upon signal.
            pthread_cond_wait(&pkt_q_cond, &pkt_q_mutex);
            }

        // If the while loop broke because a packet was added to the queue.
        if (!is_pkt_q_empty()) {
            // Dequeue packet and release mutex on packet queue.
            Packet *p = dequeue_packet();
            pthread_mutex_unlock(&pkt_q_mutex); 

            // Analyse packet for attacks, then free associated memory on heap.
            analyse(p->header, p->packet_data, verbose, stats);
            free_packet(p);

        // If instead the queue is still empty but the program termination signal was given.
        } else if (should_terminate && is_pkt_q_empty()) {
            // Release the mutex lock on the packet queue, and break the for loop.
            pthread_mutex_unlock(&pkt_q_mutex);
            break;
        }
    }  

    // Critical Section: Report stats to main thread.
    pthread_mutex_lock(&counts_mutex);
    syn_count += stats->syn_ct;
    arp_resp_count += stats->arp_ct;
    blk_url_count += stats->url_ct;
    ggl_count += stats->ggl_ct;
    analysed += stats->ays_ct;
    pthread_mutex_unlock(&counts_mutex);

    // Free memory and then terminate.
    free(stats);
    return NULL;
}

/*
 * Initialises the global IP tree by allocating memory for it.
*/
void initialise_ip_tree() {
    // Allocate memory and initialise root to null.
    ip_tree = safe_mlc(sizeof(IpTree));
    ip_tree->root = NULL;
}

/*
 * Initialises the global packet queue by allocating memory for it.
*/
void initialise_packet_queue() {
    // Allocate memory and initialise head to null.
    pkt_q = safe_mlc(sizeof(PacketQueue)); 
    pkt_q->head = NULL;
}

/*
 * Boolean function indicating whether the packet queue is empty.
 * Returns: true for empty, false for non-empty.
*/
int is_pkt_q_empty() {
    // If head is null, then queue is empty.
    if (pkt_q->head == NULL) {
        return 1;
    } else {
        return 0;
    }
}

/*
 * Enqueues a packet on the packet queue, must be used in a thread safe manner.
 * Arguments:
    p: Pointer to a packet
*/
void enqueue_packet(Packet *p) {
    // If Packet Queue empty.
    if (is_pkt_q_empty()) {
        // Make the packet both the head and tail of list.
        pkt_q->head = p;
        pkt_q->tail = p;
    // If Packet Queue non-empty.
    } else {
        // Put the packet at the tail of the list.
        Packet *tmp = pkt_q->tail;
        tmp->next = p;
        pkt_q->tail = p;
    }
}

/*
 * Dequeues packet from packet queue, must be used in a thread safe manner.
 * Returns: pointer to packet which has been dequeued.
*/
Packet *dequeue_packet() {
    // Set the second packet as the new head, and return the old head.
    Packet *tmp = pkt_q->head;
    pkt_q->head = tmp->next;
    return tmp;
}

/*
 * Frees all memory associated with a packet.
*/
void free_packet(Packet *p) {
    // Free all fields, then the packet itself.
    free(p->packet_data);
    free(p->header);
    free(p);
}

/*
 * Deallocates all memory associated with the packet queue
*/
void dismantle_packet_queue() {
    while (!is_pkt_q_empty()) {
        // Proceed along the queue, freeing packets until we reach a null packet.
        Packet *tmp = pkt_q->head;
        pkt_q->head = tmp->next;
        free(tmp);
    }
    // Free the memory allocated for the queue structure itself.
    free(pkt_q);
}

/*
 * Attempts to create pool of threads, sets error code and returns early upon failure to do so.
 * Arguments:
    error_code: Integer pointer for recording errors
*/
void initialise_thread_pool(int *error_code) {
  // Allocate memory for array of worker thread IDs.
  worker_thread_ids = safe_mlc(THREADPOOL_SIZE * sizeof(pthread_t));

  // Create worker threads.
  for (int i = 0; i < THREADPOOL_SIZE; i++)
  {
    // Check for an error each time a new thread is created, return null if it fails.
    *error_code = pthread_create(worker_thread_ids + i, NULL,
                   worker_thread_function, NULL);
    if (*error_code != 0) return;
  } // Indicate to threads that they can begin checking queue
}

/* 
 * Joins all threads, prompting them to terminate by setting the should terminate flag to 1, and frees associated memory.
*/
void dismantle_thread_pool() {

    // Set exit flag and broadcast signals.
    pthread_mutex_lock(&pkt_q_mutex);
    should_terminate = 1;
    pthread_cond_broadcast(&pkt_q_cond); // Wakes up all sleeping threads.
    pthread_mutex_unlock(&pkt_q_mutex);
    
    // Wait on all threads to join.
    for (int i = 0; i < THREADPOOL_SIZE; i++) {
        pthread_join(worker_thread_ids[i], NULL);
    }
    
    // Free the array storing thread_ids.
    free(worker_thread_ids);

    // Destroy condition variable, best practice.
    pthread_cond_destroy(&pkt_q_cond);
}

/*
 * Recursively deallocates all memory on the global IP tree, then the tree itself.
*/
void dismantle_tree() {
  // Recursively deallocate the nodes of the tree using postorder traversal.
  postorder_deallocate(ip_tree->root);

  // Deallocate the tree itself.
  free(ip_tree);
}
